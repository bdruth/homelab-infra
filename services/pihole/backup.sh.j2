#!/bin/bash

set -e

compare_file_list() {
  local current=$1; shift
  local new=$1;
  local files_changed_count=0

  # Get sorted list of relative paths (not just basenames)
  local current_files new_files
  current_files=$(cd "$current" && find . -type f -print | sort)
  new_files=$(cd "$new" && find . -type f -print | sort)

  # Find files only in current (removed)
  while read -r f; do
    if [ -n "$f" ]; then
      echo "File removed: $f" >&2
      files_changed_count=$((files_changed_count+1))
    fi
  done <<< "$(comm -23 <(echo "$current_files") <(echo "$new_files"))"

  # Find files only in new (added)
  while read -r f; do
    if [ -n "$f" ]; then
      echo "File added: $f" >&2
      files_changed_count=$((files_changed_count+1))
    fi
  done <<< "$(comm -13 <(echo "$current_files") <(echo "$new_files"))"

  echo "$files_changed_count"
}

count_json_files_changed() {
  local current=$1; shift
  local new=$1;
  local files_changed_count=0
  cd "$current"
  while read -r f
  do
    if [ -z "$f" ]; then continue; fi
    # jd returns 0 if identical, 1 if different, 2 on error
    jd -set "$f" "../$new/$f" > /dev/null 2>&1
    ec=$?
    if [ $ec -eq 1 ]; then
      echo "JSON file changed: $f" >&2
      files_changed_count=$((files_changed_count+1))
    elif [ $ec -ne 0 ]; then
      echo "JSON file compare error (ec=$ec): $f" >&2
    fi
  done <<< "$(find . -type f -name '*.json' -print | grep -vE '(client|adlist)\.json')"
  echo "$files_changed_count"
  cd ..
}

count_conf_files_changed() {
  local current=$1; shift
  local new=$1;
  local files_changed_count=0
  cd "$current"
  while read -r f
  do
    if [ -z "$f" ]; then continue; fi
    # diff returns 0 if identical, 1 if different, 2 on error
    diff "$f" "../$new/$f" > /dev/null 2>&1
    ec=$?
    if [ $ec -eq 1 ]; then
      echo "Config file changed: $f" >&2
      files_changed_count=$((files_changed_count+1))
    elif [ $ec -ne 0 ]; then
      echo "Config file compare error (ec=$ec): $f" >&2
    fi
  done <<< "$(find . -type f -not -name '*.json' -not -name '*.db' -print)"
  echo "$files_changed_count"
  cd ..
}

compare_ftl_db_config() {
  local current=$1; shift
  local new=$1;
  local files_changed_count=0

  # Tables containing configuration (not ephemeral query logs)
  local config_tables="domain_by_id client_by_id forward_by_id addinfo_by_id"

  local current_db="$current/etc/pihole/pihole-FTL.db"
  local new_db="$new/etc/pihole/pihole-FTL.db"

  # If either DB doesn't exist, consider it changed
  if [ ! -f "$current_db" ] || [ ! -f "$new_db" ]; then
    echo "1"
    return
  fi

  # Dump config tables and compare
  for table in $config_tables; do
    current_dump=$(sqlite3 "$current_db" ".dump $table" 2>/dev/null || echo "")
    new_dump=$(sqlite3 "$new_db" ".dump $table" 2>/dev/null || echo "")

    if [ "$current_dump" != "$new_dump" ]; then
      echo "FTL config table changed: $table" >&2
      files_changed_count=$((files_changed_count+1))
    fi
  done

  echo "$files_changed_count"
}

TMP_DIR=$(mktemp -d)
cd "$TMP_DIR"
# shellcheck disable=SC2154
# aws s3 cp with path style bucket reference
aws s3 cp "s3://{{ s3_teleporter_bucket_name }}/{{ s3_teleporter_object_name }}" ./pi-hole-pihole-teleporter.zip

mkdir -p current && cd current
unzip ../pi-hole-pihole-teleporter.zip && rm -f  ../pi-hole-pihole-teleporter.zip && cd ..

# generate new teleporter backup
/usr/bin/pihole-FTL --teleporter
mkdir -p new && cd new
unzip ../pi-hole*zip && cd ..

changes=0
rv=$(compare_file_list current new)
changes=$((changes+rv))
rv=$(count_json_files_changed current new)
changes=$((changes+rv))
rv=$(count_conf_files_changed current new)
changes=$((changes+rv))
rv=$(compare_ftl_db_config current new)
changes=$((changes+rv))
if [ $changes -gt 0 ]
then 
  echo "Found changes: $changes, upload new backup..."
  aws s3 cp pi-hole*.zip "s3://{{ s3_teleporter_bucket_name }}/{{ s3_teleporter_object_name }}"
fi
